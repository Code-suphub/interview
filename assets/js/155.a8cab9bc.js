(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{432:function(v,_,e){"use strict";e.r(_);var t=e(14),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"_10-1-如何查看网络的性能指标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-如何查看网络的性能指标"}},[v._v("#")]),v._v(" 10.1 如何查看网络的性能指标？")]),v._v(" "),_("p",[v._v("Linux 网络协议栈是根据 TCP/IP 模型来实现的，TCP/IP 模型由应用层、传输层、网络层和网络接口层，共四层组成，每一层都有各自的职责。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png",alt:""}})]),v._v(" "),_("p",[v._v("应用程序要发送数据包时，通常是通过 socket 接口，于是就会发生系统调用，把应用层的数据拷贝到内核里的 socket 层，接着由网络协议栈从上到下逐层处理后，最后才会送到网卡发送出去。")]),v._v(" "),_("p",[v._v("而对于接收网络包时，同样也要经过网络协议逐层处理，不过处理的方向与发送数据时是相反的，也就是从下到上的逐层处理，最后才送到应用程序。")]),v._v(" "),_("p",[v._v("网络的速度往往跟用户体验是挂钩的，那我们又该用什么指标来衡量 Linux 的网络性能呢？以及如何分析网络问题呢？")]),v._v(" "),_("p",[v._v("这次，我们就来说这些。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8F%90%E7%BA%B2.png",alt:""}})]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"性能指标有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能指标有哪些"}},[v._v("#")]),v._v(" 性能指标有哪些？")]),v._v(" "),_("p",[v._v("通常是以 4 个指标来衡量网络的性能，分别是带宽、延时、吞吐率、PPS（Packet Per Second），它们表示的意义如下：")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("带宽")]),v._v("，表示链路的最大传输速率，单位是 b/s（比特 / 秒），带宽越大，其传输能力就越强。")]),v._v(" "),_("li",[_("em",[v._v("延时")]),v._v("，表示请求数据包发送后，收到对端响应，所需要的时间延迟。不同的场景有着不同的含义，比如可以表示建立 TCP 连接所需的时间延迟，或一个数据包往返所需的时间延迟。")]),v._v(" "),_("li",[_("em",[v._v("吞吐率")]),v._v("，表示单位时间内成功传输的数据量，单位是 b/s（比特 / 秒）或者 B/s（字节 / 秒），吞吐受带宽限制，带宽越大，吞吐率的上限才可能越高。")]),v._v(" "),_("li",[_("em",[v._v("PPS")]),v._v("，全称是 Packet Per Second（包 / 秒），表示以网络包为单位的传输速率，一般用来评估系统对于网络的转发能力。")])]),v._v(" "),_("p",[v._v("当然，除了以上这四种基本的指标，还有一些其他常用的性能指标，比如：")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("网络的可用性")]),v._v("，表示网络能否正常通信；")]),v._v(" "),_("li",[_("em",[v._v("并发连接数")]),v._v("，表示 TCP 连接数量；")]),v._v(" "),_("li",[_("em",[v._v("丢包率")]),v._v("，表示所丢失数据包数量占所发送数据组的比率；")]),v._v(" "),_("li",[_("em",[v._v("重传率")]),v._v("，表示重传网络包的比例；")])]),v._v(" "),_("p",[v._v("你可能会问了，如何观测这些性能指标呢？不急，继续往下看。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"网络配置如何看"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络配置如何看"}},[v._v("#")]),v._v(" 网络配置如何看？")]),v._v(" "),_("p",[v._v("要想知道网络的配置和状态，我们可以使用 "),_("code",[v._v("ifconfig")]),v._v(" 或者 "),_("code",[v._v("ip")]),v._v(" 命令来查看。")]),v._v(" "),_("p",[v._v("这两个命令功能都差不多，不过它们属于不同的软件包，"),_("code",[v._v("ifconfig")]),v._v(" 属于 "),_("code",[v._v("net-tools")]),v._v(" 软件包，"),_("code",[v._v("ip")]),v._v(" 属于 "),_("code",[v._v("iproute2")]),v._v(" 软件包，我的印象中 "),_("code",[v._v("net-tools")]),v._v(" 软件包没有人继续维护了，而 "),_("code",[v._v("iproute2")]),v._v(" 软件包是有开发者依然在维护，所以更推荐你使用 "),_("code",[v._v("ip")]),v._v(" 工具。")]),v._v(" "),_("p",[v._v("学以致用，那就来使用这两个命令，来查看网口 "),_("code",[v._v("eth0")]),v._v(" 的配置等信息：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C/showeth0.png",alt:""}})]),v._v(" "),_("p",[v._v("虽然这两个命令输出的格式不尽相同，但是输出的内容基本相同，比如都包含了 IP 地址、子网掩码、MAC 地址、网关地址、MTU 大小、网口的状态以及网路包收发的统计信息，下面就来说说这些信息，它们都与网络性能有一定的关系。")]),v._v(" "),_("p",[v._v("第一，网口的连接状态标志。其实也就是表示对应的网口是否连接到交换机或路由器等设备，如果 "),_("code",[v._v("ifconfig")]),v._v(" 输出中看到有 "),_("code",[v._v("RUNNING")]),v._v("，或者 "),_("code",[v._v("ip")]),v._v(" 输出中有 "),_("code",[v._v("LOWER_UP")]),v._v("，则说明物理网路是连通的，如果看不到，则表示网口没有接网线。")]),v._v(" "),_("p",[v._v("第二，MTU 大小。默认值是 "),_("code",[v._v("1500")]),v._v(" 字节，其作用主要是限制网络包的大小，如果 IP 层有一个数据报要传，而且数据帧的长度比链路层的 MTU 还大，那么 IP 层就需要进行分片，即把数据报分成若干片，这样每一片就都小于 MTU。事实上，每个网络的链路层 MTU 可能会不一样，所以你可能需要调大或者调小 MTU 的数值。")]),v._v(" "),_("p",[v._v("第三，网口的 IP 地址、子网掩码、MAC 地址、网关地址。这些信息必须要配置正确，网络功能才能正常工作。")]),v._v(" "),_("p",[v._v("第四，网路包收发的统计信息。通常有网络收发的字节数、包数、错误数以及丢包情况的信息，如果 "),_("code",[v._v("TX")]),v._v("（发送）和 "),_("code",[v._v("RX")]),v._v("（接收）部分中 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，则说明网络发送或者接收出问题了，这些出错统计信息的指标意义如下：")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("errors")]),v._v(" 表示发生错误的数据包数，比如校验错误、帧同步错误等；")]),v._v(" "),_("li",[_("em",[v._v("dropped")]),v._v(" 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer（这个缓冲区是在内核内存中，更具体一点是在网卡驱动程序里），但因为系统内存不足等原因而发生的丢包；")]),v._v(" "),_("li",[_("em",[v._v("overruns")]),v._v(" 表示超限数据包数，即网络接收/发送速度过快，导致 Ring Buffer 中的数据包来不及处理，而导致的丢包，因为过多的数据包挤压在 Ring Buffer，这样 Ring Buffer 很容易就溢出了；")]),v._v(" "),_("li",[_("em",[v._v("carrier")]),v._v(" 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；")]),v._v(" "),_("li",[_("em",[v._v("collisions")]),v._v(" 表示冲突、碰撞数据包数；")])]),v._v(" "),_("p",[_("code",[v._v("ifconfig")]),v._v(" 和 "),_("code",[v._v("ip")]),v._v(" 命令只显示的是网口的配置以及收发数据包的统计信息，而看不到协议栈里的信息，那接下来就来看看如何查看协议栈里的信息。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"socket-信息如何查看"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#socket-信息如何查看"}},[v._v("#")]),v._v(" socket 信息如何查看？")]),v._v(" "),_("p",[v._v("我们可以使用 "),_("code",[v._v("netstat")]),v._v(" 或者 "),_("code",[v._v("ss")]),v._v("，这两个命令查看 socket、网络协议栈、网口以及路由表的信息。")]),v._v(" "),_("p",[v._v("虽然 "),_("code",[v._v("netstat")]),v._v(" 与 "),_("code",[v._v("ss")]),v._v(" 命令查看的信息都差不多，但是如果在生产环境中要查看这类信息的时候，尽量不要使用 "),_("code",[v._v("netstat")]),v._v(" 命令，因为它的性能不好，在系统比较繁忙的情况下，如果频繁使用 "),_("code",[v._v("netstat")]),v._v(" 命令则会对性能的开销雪上加霜，所以更推荐你使用性能更好的 "),_("code",[v._v("ss")]),v._v(" 命令。")]),v._v(" "),_("p",[v._v("从下面这张图，你可以看到这两个命令的输出内容：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C/showsocket.png",alt:""}})]),v._v(" "),_("p",[v._v("可以发现，输出的内容都差不多，比如都包含了 socket 的状态（"),_("em",[v._v("State")]),v._v("）、接收队列（"),_("em",[v._v("Recv-Q")]),v._v("）、发送队列（"),_("em",[v._v("Send-Q")]),v._v("）、本地地址（"),_("em",[v._v("Local Address")]),v._v("）、远端地址（"),_("em",[v._v("Foreign Address")]),v._v("）、进程 PID 和进程名称（"),_("em",[v._v("PID/Program name")]),v._v("）等。")]),v._v(" "),_("p",[v._v("接收队列（"),_("em",[v._v("Recv-Q")]),v._v("）和发送队列（"),_("em",[v._v("Send-Q")]),v._v("）比较特殊，在不同的 socket 状态。它们表示的含义是不同的。")]),v._v(" "),_("p",[v._v("当 socket 状态处于 "),_("code",[v._v("Established")]),v._v("时：")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("Recv-Q")]),v._v(" 表示 socket 缓冲区中还没有被应用程序读取的字节数；")]),v._v(" "),_("li",[_("em",[v._v("Send-Q")]),v._v(" 表示 socket 缓冲区中还没有被远端主机确认的字节数；")])]),v._v(" "),_("p",[v._v("而当 socket 状态处于 "),_("code",[v._v("Listen")]),v._v(" 时：")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("Recv-Q")]),v._v(" 表示全连接队列的长度；")]),v._v(" "),_("li",[_("em",[v._v("Send-Q")]),v._v(" 表示全连接队列的最大长度；")])]),v._v(" "),_("p",[v._v("在 TCP 三次握手过程中，当服务器收到客户端的 SYN 包后，内核会把该连接存储到半连接队列，然后再向客户端发送 SYN+ACK 包，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其增加到全连接队列，等待进程调用 "),_("code",[v._v("accept()")]),v._v(" 函数时把连接取出来。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5/3.jpg",alt:"半连接队列与全连接队列"}})]),v._v(" "),_("p",[v._v("也就说，全连接队列指的是服务器与客户端完了 TCP 三次握手后，还没有被 "),_("code",[v._v("accept()")]),v._v(" 系统调用取走连接的队列。")]),v._v(" "),_("p",[v._v("那对于协议栈的统计信息，依然还是使用 "),_("code",[v._v("netstat")]),v._v(" 或 "),_("code",[v._v("ss")]),v._v("，它们查看统计信息的命令如下：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C/showinfo.png",alt:""}})]),v._v(" "),_("p",[_("code",[v._v("ss")]),v._v(" 命令输出的统计信息相比 "),_("code",[v._v("netsat")]),v._v(" 比较少，"),_("code",[v._v("ss")]),v._v(" 只显示已经连接（"),_("em",[v._v("estab")]),v._v("）、关闭（"),_("em",[v._v("closed")]),v._v("）、孤儿（"),_("em",[v._v("orphaned")]),v._v("）socket 等简要统计。")]),v._v(" "),_("p",[v._v("而 "),_("code",[v._v("netstat")]),v._v(" 则有更详细的网络协议栈信息，比如上面显示了 TCP 协议的主动连接（"),_("em",[v._v("active connections openings")]),v._v("）、被动连接（"),_("em",[v._v("passive connection openings")]),v._v("）、失败重试（"),_("em",[v._v("failed connection attempts")]),v._v("）、发送（"),_("em",[v._v("segments send out")]),v._v("）和接收（"),_("em",[v._v("segments received")]),v._v("）的分段数量等各种信息。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"网络吞吐率和-pps-如何查看"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络吞吐率和-pps-如何查看"}},[v._v("#")]),v._v(" 网络吞吐率和 PPS 如何查看？")]),v._v(" "),_("p",[v._v("可以使用 "),_("code",[v._v("sar")]),v._v(" 命令当前网络的吞吐率和 PPS，用法是给 "),_("code",[v._v("sar")]),v._v(" 增加 "),_("code",[v._v("-n")]),v._v(" 参数就可以查看网络的统计信息，比如")]),v._v(" "),_("ul",[_("li",[v._v("sar -n DEV，显示网口的统计数据；")]),v._v(" "),_("li",[v._v("sar -n EDEV，显示关于网络错误的统计数据；")]),v._v(" "),_("li",[v._v("sar -n TCP，显示 TCP 的统计数据")])]),v._v(" "),_("p",[v._v("比如，我通过 "),_("code",[v._v("sar")]),v._v(" 命令获取了网口的统计信息：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C/sar.png",alt:""}})]),v._v(" "),_("p",[v._v("它们的含义：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("rxpck/s")]),v._v(" 和 "),_("code",[v._v("txpck/s")]),v._v(" 分别是接收和发送的 PPS，单位为包 / 秒。")]),v._v(" "),_("li",[_("code",[v._v("rxkB/s")]),v._v(" 和 "),_("code",[v._v("txkB/s")]),v._v(" 分别是接收和发送的吞吐率，单位是 KB/ 秒。")]),v._v(" "),_("li",[_("code",[v._v("rxcmp/s")]),v._v(" 和 "),_("code",[v._v("txcmp/s")]),v._v(" 分别是接收和发送的压缩数据包数，单位是包 / 秒。")])]),v._v(" "),_("p",[v._v("对于带宽，我们可以使用 "),_("code",[v._v("ethtool")]),v._v(" 命令来查询，它的单位通常是 "),_("code",[v._v("Gb/s")]),v._v(" 或者 "),_("code",[v._v("Mb/s")]),v._v("，不过注意这里小写字母 "),_("code",[v._v("b")]),v._v(" ，表示比特而不是字节。我们通常提到的千兆网卡、万兆网卡等，单位也都是比特（"),_("em",[v._v("bit")]),v._v("）。如下你可以看到，eth0 网卡就是一个千兆网卡：")]),v._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[v._v("$ "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("ethtool")]),v._v(" eth0 "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("|")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("grep")]),v._v(" Speed\n  Speed: 1000Mb/s\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("hr"),v._v(" "),_("h2",{attrs:{id:"连通性和延时如何查看"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连通性和延时如何查看"}},[v._v("#")]),v._v(" 连通性和延时如何查看？")]),v._v(" "),_("p",[v._v("要测试本机与远程主机的连通性和延时，通常是使用 "),_("code",[v._v("ping")]),v._v(" 命令，它是基于 ICMP 协议的，工作在网络层。")]),v._v(" "),_("p",[v._v("比如，如果要测试本机到 "),_("code",[v._v("192.168.12.20")]),v._v(" IP 地址的连通性和延时：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C/ping.png",alt:""}})]),v._v(" "),_("p",[v._v("显示的内容主要包含  "),_("code",[v._v("icmp_seq")]),v._v("（ICMP 序列号）、"),_("code",[v._v("TTL")]),v._v("（生存时间，或者跳数）以及 "),_("code",[v._v("time")]),v._v(" （往返延时），而且最后会汇总本次测试的情况，如果网络没有丢包，"),_("code",[v._v("packet loss")]),v._v(" 的百分比就是 0。")]),v._v(" "),_("p",[v._v("不过，需要注意的是，"),_("code",[v._v("ping")]),v._v(" 不通服务器并不代表 HTTP 请求也不通，因为有的服务器的防火墙是会禁用 ICMP 协议的。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"关注作者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关注作者"}},[v._v("#")]),v._v(" 关注作者")]),v._v(" "),_("p",[_("em",[_("strong",[v._v("哈喽，我是小林，就爱图解计算机基础，如果觉得文章对你有帮助，欢迎微信搜索「小林 coding」，关注后，回复「网络」再送你图解网络 PDF")])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png",alt:""}})])])}),[],!1,null,null,null);_.default=s.exports}}]);