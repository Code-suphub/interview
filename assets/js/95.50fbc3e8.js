(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{372:function(s,t,a){"use strict";a.r(t);var n=a(14),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"_4-20-没有-accept-能建立-tcp-连接吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-20-没有-accept-能建立-tcp-连接吗"}},[s._v("#")]),s._v(" 4.20 没有 accept，能建立 TCP 连接吗？")]),s._v(" "),t("blockquote",[t("p",[s._v("来源：公众号@小白 debug\n原文地址："),t("a",{attrs:{href:"https://mp.weixin.qq.com/s/oPX_JoZUaLn6sW54yppfvA",target:"_blank",rel:"noopener noreferrer"}},[s._v("阿里二面：没有 accept，能建立 TCP 连接吗？"),t("OutboundLink")],1)])]),s._v(" "),t("p",[s._v("大家好，我是小林。")]),s._v(" "),t("p",[s._v("这次，我们来讨论一下，"),t("strong",[s._v("没有 accept，能建立 TCP 连接吗？")])]),s._v(" "),t("p",[s._v("下面这个动图，是我们平时客户端和服务端建立连接时的代码流程。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/e0d405a55626eb8e4a52553a54680618.gif",alt:"握手建立连接流程"}})]),s._v(" "),t("p",[s._v("对应的是下面一段简化过的服务端伪代码。")]),s._v(" "),t("div",{staticClass:"language-c line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*Step 1: 创建服务器端监听 socket 描述符 listen_fd*/")]),s._v("    \n    listen_fd "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("socket")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("AF_INET"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" SOCK_STREAM"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*Step 2: bind 绑定服务器端的 IP 和端口，所有客户端都向这个 IP 和端口发送和请求数据*/")]),s._v("    \n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("bind")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("listen_fd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" xxx"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*Step 3: 服务端开启监听*/")]),s._v("    \n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("listen")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("listen_fd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("128")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*Step 4: 服务器等待客户端的链接，返回值 cfd 为客户端的 socket 描述符*/")]),s._v("    \n    cfd "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("accept")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("listen_fd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" xxx"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*Step 5: 读取客户端发来的数据*/")]),s._v("\n    n "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("read")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("cfd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" buf"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("sizeof")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("buf"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br")])]),t("p",[s._v("估计大家也是老熟悉这段伪代码了。")]),s._v(" "),t("p",[s._v("需要注意的是，在执行 "),t("code",[s._v("listen()")]),s._v(" 方法之后还会执行一个 "),t("code",[s._v("accept()")]),s._v(" 方法。")]),s._v(" "),t("p",[t("strong",[s._v("一般情况")]),s._v("下，如果启动服务器，会发现最后程序会"),t("strong",[s._v("阻塞在")]),s._v(" "),t("code",[s._v("accept()")]),s._v(" 里。")]),s._v(" "),t("p",[s._v("此时服务端就算 ok 了，就等客户端了。")]),s._v(" "),t("p",[s._v("那么，再看下简化过的客户端伪代码。")]),s._v(" "),t("div",{staticClass:"language-c line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*Step 1: 创建客户端端 socket 描述符 cfd*/")]),s._v("    \n    cfd "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("socket")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("AF_INET"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" SOCK_STREAM"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*Step 2: connect 方法，对服务器端的 IP 和端口号发起连接*/")]),s._v("    \n    ret "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("connect")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("cfd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" xxxx"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*Step 3: 向服务器端写数据*/")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("write")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("cfd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" buf"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("strlen")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("buf"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br")])]),t("p",[s._v("客户端比较简单，创建好 "),t("code",[s._v("socket")]),s._v(" 之后，直接就发起 "),t("code",[s._v("connect")]),s._v(" 方法。")]),s._v(" "),t("p",[s._v("此时回到服务端，会发现"),t("strong",[s._v("之前一直阻塞的 accept 方法，返回结果了")]),s._v("。")]),s._v(" "),t("p",[s._v("这就算两端成功建立好了一条连接。之后就可以愉快的进行读写操作了。")]),s._v(" "),t("p",[s._v("那么，我们今天的问题是，"),t("strong",[s._v("如果没有这个 accept 方法，TCP 连接还能建立起来吗？")])]),s._v(" "),t("p",[s._v("其实只要在执行 "),t("code",[s._v("accept()")]),s._v(" 之前执行一个 "),t("code",[s._v("sleep(20)")]),s._v("，然后立刻执行客户端相关的方法，同时抓个包，就能得出结论。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2cfc1d028f3e37f10c2f81375ddb998a.png",alt:"不执行 accept 时抓包结果"}})]),s._v(" "),t("p",[s._v("从抓包结果看来，"),t("strong",[s._v("就算不执行 "),t("code",[s._v("accept()")]),s._v(" 方法，三次握手照常进行，并顺利建立连接。")])]),s._v(" "),t("p",[s._v("更骚气的是，"),t("strong",[s._v("在服务端执行 "),t("code",[s._v("accept()")]),s._v(" 前，如果客户端发送消息给服务端，服务端是能够正常回复 ack 确认包的。")])]),s._v(" "),t("p",[s._v("并且，"),t("code",[s._v("sleep(20)")]),s._v(" 结束后，服务端正常执行 "),t("code",[s._v("accept()")]),s._v("，客户端前面发送的消息，还是能正常收到的。")]),s._v(" "),t("p",[s._v("通过这个现象，我们可以多想想为什么。顺便好好了解下三次握手的细节。")]),s._v(" "),t("h2",{attrs:{id:"三次握手的细节分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手的细节分析"}},[s._v("#")]),s._v(" 三次握手的细节分析")]),s._v(" "),t("p",[s._v("我们先看面试八股文的老股，三次握手。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/8d55a06f2efa946921ff61a008c76b00.png",alt:"TCP 三次握手"}})]),s._v(" "),t("p",[s._v("服务端代码，对 socket 执行 bind 方法可以绑定监听端口，然后执行 "),t("code",[s._v("listen")]),s._v(" 方法后，就会进入监听（"),t("code",[s._v("LISTEN")]),s._v("）状态。内核会为每一个处于 "),t("code",[s._v("LISTEN")]),s._v(" 状态的 "),t("code",[s._v("socket")]),s._v(" 分配两个队列，分别叫"),t("strong",[s._v("半连接队列和全连接队列")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d7e2d60b28b0f9b460aafbf1bd6e7892.png",alt:"每个 listen Socket 都有一个全连接和半连接队列"}})]),s._v(" "),t("h3",{attrs:{id:"半连接队列、全连接队列是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#半连接队列、全连接队列是什么"}},[s._v("#")]),s._v(" 半连接队列、全连接队列是什么")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/36242c85809865fcd2da48594de15ebb.png",alt:"半连接队列和全连接队列"}})]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("半连接队列（"),t("code",[s._v("SYN")]),s._v(" 队列）")]),s._v("，服务端收到"),t("strong",[s._v("第一次握手")]),s._v("后，会将 "),t("code",[s._v("sock")]),s._v(" 加入到这个队列中，队列内的 "),t("code",[s._v("sock")]),s._v(" 都处于 "),t("code",[s._v("SYN_RECV")]),s._v(" 状态。")]),s._v(" "),t("li",[t("strong",[s._v("全连接队列（"),t("code",[s._v("ACCEPT")]),s._v(" 队列）")]),s._v("，在服务端收到"),t("strong",[s._v("第三次握手")]),s._v("后，会将半连接队列的 "),t("code",[s._v("sock")]),s._v(" 取出，放到全连接队列中。队列里的 "),t("code",[s._v("sock")]),s._v(" 都处于 "),t("code",[s._v("ESTABLISHED")]),s._v(" 状态。这里面的连接，就"),t("strong",[s._v("等着服务端执行 "),t("code",[s._v("accept()")]),s._v(" 后被取出了。")])])]),s._v(" "),t("p",[s._v("看到这里，文章开头的问题就有了答案，建立连接的过程中根本不需要 "),t("code",[s._v("accept()")]),s._v(" 参与， "),t("strong",[s._v("执行 "),t("code",[s._v("accept()")]),s._v(" 只是为了从全连接队列里取出一条连接。")])]),s._v(" "),t("p",[s._v("我们把话题再重新回到这两个队列上。")]),s._v(" "),t("p",[s._v("虽然都叫"),t("strong",[s._v("队列")]),s._v("，但其实"),t("strong",[s._v("全连接队列（icsk_accept_queue）是个链表")]),s._v("，而"),t("strong",[s._v("半连接队列（syn_table）是个哈希表")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/6f964fb09d6971dab1762a45dfa30b3b.png",alt:"半连接全连接队列的内部结构"}})]),s._v(" "),t("h3",{attrs:{id:"为什么半连接队列要设计成哈希表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么半连接队列要设计成哈希表"}},[s._v("#")]),s._v(" 为什么半连接队列要设计成哈希表")]),s._v(" "),t("p",[s._v("先对比下"),t("strong",[s._v("全连接里队列")]),s._v("，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为 "),t("code",[s._v("O(1)")]),s._v("。")]),s._v(" "),t("p",[s._v("而"),t("strong",[s._v("半连接队列")]),s._v("却不太一样，因为队列里的都是不完整的连接，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应 IP 端口的连接取出，"),t("strong",[s._v("如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是 "),t("code",[s._v("O(n)")]),s._v("。")])]),s._v(" "),t("p",[s._v("而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到 "),t("code",[s._v("O(1)")]),s._v(" 了。")]),s._v(" "),t("p",[s._v("因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。")]),s._v(" "),t("h3",{attrs:{id:"怎么观察两个队列的大小"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么观察两个队列的大小"}},[s._v("#")]),s._v(" 怎么观察两个队列的大小")]),s._v(" "),t("h4",{attrs:{id:"查看全连接队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看全连接队列"}},[s._v("#")]),s._v(" 查看全连接队列")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# ss -lnt")]),s._v("\nState      Recv-Q Send-Q     Local Address:Port           Peer Address:Port\nLISTEN     "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("      "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("128")]),s._v("        "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:46269              *:*              \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("通过 "),t("code",[s._v("ss -lnt")]),s._v(" 命令，可以看到全连接队列的大小，其中 "),t("code",[s._v("Send-Q")]),s._v(" 是指全连接队列的最大值，可以看到我这上面的最大值是 "),t("code",[s._v("128")]),s._v("；"),t("code",[s._v("Recv-Q")]),s._v(" 是指当前的全连接队列的使用值，我这边用了 "),t("code",[s._v("0")]),s._v(" 个，也就是全连接队列里为空，连接都被取出来了。")]),s._v(" "),t("p",[s._v("当上面 "),t("code",[s._v("Send-Q")]),s._v(" 和 "),t("code",[s._v("Recv-Q")]),s._v(" 数值很接近的时候，那么全连接队列可能已经满了。可以通过下面的命令查看是否发生过队列"),t("strong",[s._v("溢出")]),s._v("。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# netstat -s | grep overflowed")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4343")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("times")]),s._v(" the listen queue of a socket overflowed\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("上面说明发生过 "),t("code",[s._v("4343")]),s._v(" 次全连接队列溢出的情况。这个查看到的是"),t("strong",[s._v("历史发生过的次数")]),s._v("。")]),s._v(" "),t("p",[s._v("如果配合使用 "),t("code",[s._v("watch -d")]),s._v(" 命令，可以自动每 "),t("code",[s._v("2s")]),s._v(" 间隔执行相同命令，还能高亮显示变化的数字部分，如果溢出的数字不断变多，说明"),t("strong",[s._v("正在发生")]),s._v("溢出的行为。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# watch -d 'netstat -s | grep overflowed'")]),s._v("\nEvery "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(".0s: "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("netstat")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-s")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("grep")]),s._v(" overflowed                                \nFri Sep "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" 09:00:45 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2021")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4343")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("times")]),s._v(" the listen queue of a socket overflowed\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h4",{attrs:{id:"查看半连接队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看半连接队列"}},[s._v("#")]),s._v(" 查看半连接队列")]),s._v(" "),t("p",[s._v("半连接队列没有命令可以直接查看到，但因为半连接队列里，放的都是 "),t("code",[s._v("SYN_RECV")]),s._v(" 状态的连接，那可以通过统计处于这个状态的连接的数量，间接获得半连接队列的长度。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# netstat -nt | grep -i '127.0.0.1:8080' | grep -i 'SYN_RECV' | wc -l")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("注意半连接队列和全连接队列都是挂在某个 "),t("code",[s._v("Listen socket")]),s._v(" 上的，我这里用的是 "),t("code",[s._v("127.0.0.1:8080")]),s._v("，大家可以替换成自己想要查看的 "),t("strong",[s._v("IP 端口")]),s._v("。")]),s._v(" "),t("p",[s._v("可以看到我的机器上的半连接队列长度为 "),t("code",[s._v("0")]),s._v("，这个很正常，"),t("strong",[s._v("正经连接谁会没事老待在半连接队列里。")])]),s._v(" "),t("p",[s._v("当队列里的半连接不断增多，最终也是会发生溢出，可以通过下面的命令查看。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v('# netstat -s | grep -i "SYNs to LISTEN sockets dropped" ')]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("26395")]),s._v(" SYNs to LISTEN sockets dropped\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("可以看到，我的机器上一共发生了 "),t("code",[s._v("26395")]),s._v(" 次半连接队列溢出。同样建议配合 "),t("code",[s._v("watch -d")]),s._v(" 命令使用。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# watch -d 'netstat -s | grep -i \"SYNs to LISTEN sockets dropped\"'")]),s._v("\nEvery "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(".0s: "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("netstat")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-s")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("grep")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-i")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"SYNs to LISTEN sockets dropped"')]),s._v("       \nFri Sep "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" 08:36:38 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2021")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("26395")]),s._v(" SYNs to LISTEN sockets dropped\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h3",{attrs:{id:"全连接队列满了会怎么样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全连接队列满了会怎么样"}},[s._v("#")]),s._v(" 全连接队列满了会怎么样？")]),s._v(" "),t("p",[s._v("如果队列满了，服务端还收到客户端的第三次握手 ACK，默认当然会丢弃这个 ACK。")]),s._v(" "),t("p",[s._v("但除了丢弃之外，还有一些附带行为，这会受 "),t("code",[s._v("tcp_abort_on_overflow")]),s._v(" 参数的影响。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# cat /proc/sys/net/ipv4/tcp_abort_on_overflow")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("ul",[t("li",[t("code",[s._v("tcp_abort_on_overflow")]),s._v(" 设置为 "),t("code",[s._v("0")]),s._v("，全连接队列满了之后，会丢弃这个第三次握手 ACK 包，并且开启定时器，重传第二次握手的 SYN+ACK，如果重传超过一定限制次数，还会把对应的"),t("strong",[s._v("半连接队列里的连接")]),s._v("给删掉。")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/874f2fb7108020fd4dcfa021f377ec66.png",alt:"tcp_abort_on_overflow 为 0"}})]),s._v(" "),t("ul",[t("li",[t("code",[s._v("tcp_abort_on_overflow")]),s._v("设置为 "),t("code",[s._v("1")]),s._v("，全连接队列满了之后，就直接发 RST 给客户端，效果上看就是连接断了。")])]),s._v(" "),t("p",[s._v("这个现象是不是很熟悉，服务端"),t("strong",[s._v("端口未监听")]),s._v("时，客户端尝试去连接，服务端也会回一个 RST。这两个情况长一样，所以客户端这时候收到 RST 之后，其实无法区分到底是"),t("strong",[s._v("端口未监听")]),s._v("，还是"),t("strong",[s._v("全连接队列满了")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/6a01c5df74748870a69921da89825d9c.png",alt:"tcp_abort_on_overflow 为 1"}})]),s._v(" "),t("h3",{attrs:{id:"半连接队列要是满了会怎么样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#半连接队列要是满了会怎么样"}},[s._v("#")]),s._v(" 半连接队列要是满了会怎么样")]),s._v(" "),t("p",[t("strong",[s._v("一般是丢弃")]),s._v("，但这个行为可以通过 "),t("code",[s._v("tcp_syncookies")]),s._v(" 参数去控制。但比起这个，更重要的是先了解下半连接队列为什么会被打满。")]),s._v(" "),t("p",[s._v('首先我们需要明白，一般情况下，半连接的"生存"时间其实很短，只有在第一次和第三次握手间，如果半连接都满了，说明服务端疯狂收到第一次握手请求，如果是线上游戏应用，能有这么多请求进来，那说明你可能要富了。但现实往往比较骨感，你可能遇到了 '),t("strong",[s._v("SYN Flood 攻击")]),s._v("。")]),s._v(" "),t("p",[s._v("所谓 "),t("strong",[s._v("SYN Flood 攻击")]),s._v("，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d894de5374a12bd5d75d86d4a718d186.png",alt:"syn 攻击"}})]),s._v(" "),t("p",[s._v("那这种情况怎么处理？有没有一种方法可以"),t("strong",[s._v("绕过半连接队列")]),s._v("？")]),s._v(" "),t("p",[s._v("有，上面提到的 "),t("code",[s._v("tcp_syncookies")]),s._v(" 派上用场了。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# cat /proc/sys/net/ipv4/tcp_syncookies")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("当它被设置为 "),t("code",[s._v("1")]),s._v(" 的时候，客户端发来"),t("strong",[s._v("第一次握手")]),s._v(" SYN 时，服务端"),t("strong",[s._v("不会将其放入半连接队列中")]),s._v("，而是直接生成一个 "),t("code",[s._v("cookies")]),s._v("，这个 "),t("code",[s._v("cookies")]),s._v(" 会跟着"),t("strong",[s._v("第二次握手")]),s._v("，发回客户端。客户端在发"),t("strong",[s._v("第三次握手")]),s._v("的时候带上这个 "),t("code",[s._v("cookies")]),s._v("，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/d696b8b345526533bde8fa990e205c32.png",alt:"tcp_syncookies=1"}})]),s._v(" "),t("h4",{attrs:{id:"会有一个-cookies-队列吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#会有一个-cookies-队列吗"}},[s._v("#")]),s._v(" 会有一个 cookies 队列吗")]),s._v(" "),t("p",[s._v("生成是 "),t("code",[s._v("cookies")]),s._v("，保存在哪呢？"),t("strong",[s._v("是不是会有一个队列保存这些 cookies？")])]),s._v(" "),t("p",[s._v("我们可以反过来想一下，如果有 "),t("code",[s._v("cookies")]),s._v(" 队列，那它会跟半连接队列一样，到头来，还是会被 "),t("strong",[s._v("SYN Flood 攻击")]),s._v("打满。")]),s._v(" "),t("p",[s._v("实际上 "),t("code",[s._v("cookies")]),s._v(" 并不会有一个专门的队列保存，它是通过"),t("strong",[s._v("通信双方的 IP 地址端口、时间戳、MSS")]),s._v("等信息进行"),t("strong",[s._v("实时计算")]),s._v("的，保存在 "),t("strong",[s._v("TCP 报头")]),s._v("的 "),t("code",[s._v("seq")]),s._v(" 里。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/6d280b0946a73ea6185653cbcfcc489f.png",alt:"tcp 报头_seq 的位置"}})]),s._v(" "),t("p",[s._v("当服务端收到客户端发来的第三次握手包时，会通过 seq 还原出"),t("strong",[s._v("通信双方的 IP 地址端口、时间戳、MSS")]),s._v("，验证通过则建立连接。")]),s._v(" "),t("h4",{attrs:{id:"cookies-方案为什么不直接取代半连接队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookies-方案为什么不直接取代半连接队列"}},[s._v("#")]),s._v(" cookies 方案为什么不直接取代半连接队列？")]),s._v(" "),t("p",[s._v("目前看下来 "),t("code",[s._v("syn cookies")]),s._v(" 方案省下了半连接队列所需要的队列内存，还能解决 "),t("strong",[s._v("SYN Flood 攻击")]),s._v("，那为什么不直接取代半连接队列？")]),s._v(" "),t("p",[s._v("凡事皆有利弊，"),t("code",[s._v("cookies")]),s._v(" 方案虽然能防 "),t("strong",[s._v("SYN Flood 攻击")]),s._v("，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。")]),s._v(" "),t("p",[s._v("另外，编码解码 "),t("code",[s._v("cookies")]),s._v("，都是比较"),t("strong",[s._v("耗 CPU")]),s._v(" 的，利用这一点，如果此时攻击者构造大量的"),t("strong",[s._v("第三次握手包（ACK 包）")]),s._v("，同时带上各种瞎编的 "),t("code",[s._v("cookies")]),s._v(" 信息，服务端收到 "),t("code",[s._v("ACK 包")]),s._v("后"),t("strong",[s._v("以为是正经 cookies")]),s._v("，憨憨地跑去解码（"),t("strong",[s._v("耗 CPU")]),s._v("），最后发现不是正经数据包后才丢弃。")]),s._v(" "),t("p",[s._v("这种通过构造大量 "),t("code",[s._v("ACK 包")]),s._v("去消耗服务端资源的攻击，叫 "),t("strong",[s._v("ACK 攻击")]),s._v("，受到攻击的服务器可能会因为 "),t("strong",[s._v("CPU 资源耗尽")]),s._v("导致没能响应正经请求。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/15a0a5f7fe15ee2bc5e07492eda5a8ea.gif",alt:"ack 攻击"}})]),s._v(" "),t("h3",{attrs:{id:"没有-listen-为什么还能建立连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#没有-listen-为什么还能建立连接"}},[s._v("#")]),s._v(" 没有 listen，为什么还能建立连接")]),s._v(" "),t("p",[s._v("那既然没有 "),t("code",[s._v("accept")]),s._v(" 方法能建立连接，那是不是没有 "),t("code",[s._v("listen")]),s._v(" 方法，也能建立连接？是的，之前写的一篇文章提到过客户端是可以自己连自己的形成连接（"),t("strong",[s._v("TCP 自连接")]),s._v("），也可以两个客户端同时向对方发出请求建立连接（"),t("strong",[s._v("TCP 同时打开")]),s._v("），这两个情况都有个共同点，就是"),t("strong",[s._v("没有服务端参与，也就是没有 listen，就能建立连接。")])]),s._v(" "),t("p",[s._v("当时文章最后也留了个疑问，"),t("strong",[s._v("没有 listen，为什么还能建立连接？")])]),s._v(" "),t("p",[s._v("我们知道执行 "),t("code",[s._v("listen")]),s._v(" 方法时，会创建半连接队列和全连接队列。")]),s._v(" "),t("p",[s._v("三次握手的过程中会在这两个队列中暂存连接信息。")]),s._v(" "),t("p",[s._v("所以形成连接，前提是你得"),t("strong",[s._v("有个地方存放着")]),s._v("，方便握手的时候能根据 IP 端口等信息找到 socket 信息。")]),s._v(" "),t("p",[t("strong",[s._v("那么客户端会有半连接队列吗？")])]),s._v(" "),t("p",[t("strong",[s._v("显然没有")]),s._v("，因为客户端没有执行 "),t("code",[s._v("listen")]),s._v("，因为半连接队列和全连接队列都是在执行 "),t("code",[s._v("listen")]),s._v(" 方法时，内核自动创建的。")]),s._v(" "),t("p",[s._v("但内核还有个"),t("strong",[s._v("全局 "),t("code",[s._v("hash")]),s._v(" 表")]),s._v("，可以用于存放 "),t("code",[s._v("sock")]),s._v(" 连接的信息。这个全局 "),t("code",[s._v("hash")]),s._v(" 表其实还细分为 "),t("code",[s._v("ehash，bhash和listen_hash")]),s._v(" 等，但因为过于细节，大家理解成有一个"),t("strong",[s._v("全局 hash")]),s._v(" 就够了。")]),s._v(" "),t("p",[s._v("在 TCP 自连接的情况中，客户端在 "),t("code",[s._v("connect")]),s._v(" 方法时，最后会将自己的连接信息放入到这个"),t("strong",[s._v("全局 hash 表")]),s._v("中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP 端口信息，再一次从这个"),t("strong",[s._v("全局 hash")]),s._v(" 中取出信息。于是握手包一来一回，最后成功建立连接。")]),s._v(" "),t("p",[s._v("TCP 同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。")]),s._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("每一个")]),s._v(" "),t("code",[s._v("socket")]),s._v(" 执行 "),t("code",[s._v("listen")]),s._v(" 时，内核都会自动创建一个半连接队列和全连接队列。")]),s._v(" "),t("li",[s._v("第三次握手前，TCP 连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。")]),s._v(" "),t("li",[t("code",[s._v("accept")]),s._v(" 方法只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎"),t("strong",[s._v("毫无关系")]),s._v("。")]),s._v(" "),t("li",[s._v("出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了"),t("strong",[s._v("哈希表")]),s._v("，而全连接队列本质是链表。")]),s._v(" "),t("li",[s._v("全连接队列满了，再来第三次握手也会丢弃，此时如果 "),t("code",[s._v("tcp_abort_on_overflow=1")]),s._v("，还会直接发 "),t("code",[s._v("RST")]),s._v(" 给客户端。")]),s._v(" "),t("li",[s._v("半连接队列满了，可能是因为受到了 "),t("code",[s._v("SYN Flood")]),s._v(" 攻击，可以设置 "),t("code",[s._v("tcp_syncookies")]),s._v("，绕开半连接队列。")]),s._v(" "),t("li",[s._v("客户端没有半连接队列和全连接队列，但有一个"),t("strong",[s._v("全局 hash")]),s._v("，可以通过它实现自连接或 TCP 同时打开。")])]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("最新的图解文章都在公众号首发，别忘记关注哦！！如果你想加入百人技术交流群，扫码下方二维码回复「加群」。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png",alt:"img"}})])])}),[],!1,null,null,null);t.default=e.exports}}]);